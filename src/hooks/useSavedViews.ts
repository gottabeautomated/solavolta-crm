import useSWR from 'swr'
import { useCallback, useMemo, useEffect, useState } from 'react'
import { supabase } from '../lib/supabase'
import { useAuthContext } from '../contexts/AuthContext'

export type FilterLogic = 'AND' | 'OR'

export interface SavedViewFilters {
  logic?: FilterLogic
  zipRanges?: { from: string; to: string }[]
  roofTypes?: string[]
  priorities?: ('low'|'medium'|'high'|'overdue')[]
  owners?: string[]
  onlyToday?: boolean
  autoGenerated?: boolean | 'auto' | 'manual'
}

export interface SavedView {
  id: string
  tenant_id: string
  user_id: string
  name: string
  filters_json: SavedViewFilters
  is_default: boolean
  shared_to_all?: boolean
  slug?: string | null
  created_at: string
  updated_at: string
}

function slugify(name: string): string {
  return name
    .toLowerCase()
    .trim()
    .replace(/ä/g, 'ae')
    .replace(/ö/g, 'oe')
    .replace(/ü/g, 'ue')
    .replace(/ß/g, 'ss')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

function setUrlView(slug: string | null) {
  try {
    const url = new URL(window.location.href)
    if (slug) url.searchParams.set('view', slug)
    else url.searchParams.delete('view')
    window.history.replaceState({}, '', url.toString())
  } catch {}
}

export function useSavedViews() {
  const { activeTenantId, user } = useAuthContext()
  const key = activeTenantId && user ? ['saved_views', activeTenantId, user.id] : null
  const storageKey = user && activeTenantId ? `sv_active_view_${activeTenantId}_${user.id}` : null
  const [activeViewId, setActiveViewIdState] = useState<string | null>(null)

  const { data, error, isLoading, mutate } = useSWR<SavedView[]>(
    key,
    async () => {
      const { data, error } = await supabase
        .from('saved_views')
        .select('*')
        .eq('tenant_id', activeTenantId)
        .eq('user_id', user!.id)
        .order('is_default', { ascending: false })
        .order('created_at', { ascending: true })
      if (error) {
        const msg = error?.message || ''
        if (msg.includes('404') || msg.toLowerCase().includes('not found')) {
          return [] as SavedView[]
        }
        throw error
      }
      return (data || []) as SavedView[]
    },
    { revalidateOnFocus: false, shouldRetryOnError: false }
  )

  // Initialize active view from URL -> storage -> default
  useEffect(() => {
    if (!data) return
    // Only set initial once (do not override user selection)
    setActiveViewIdState(prev => {
      if (prev !== null) return prev
      // URL wins
      try {
        const url = new URL(window.location.href)
        const v = url.searchParams.get('view')
        if (v) {
          const bySlug = data.find(x => (x.slug || slugify(x.name)) === v)
          if (bySlug) return bySlug.id
        }
      } catch {}
      const stored = storageKey ? localStorage.getItem(storageKey) : null
      const exists = stored && data.some(v => v.id === stored)
      const def = data.find(v => v.is_default)
      return exists ? stored! : (def?.id || null)
    })
  }, [data, storageKey])

  const setActiveViewId = useCallback((id: string | null) => {
    setActiveViewIdState(id)
    if (storageKey) {
      if (id) localStorage.setItem(storageKey, id)
      else localStorage.removeItem(storageKey)
    }
    // Update URL param
    if (id && data) {
      const v = data.find(x => x.id === id)
      setUrlView(v?.slug || (v ? slugify(v.name) : null))
    } else {
      setUrlView(null)
    }
  }, [storageKey, data])

  const create = useCallback(async (name: string, filters: SavedViewFilters, isDefault = false, sharedToAll = false) => {
    if (!activeTenantId || !user) throw new Error('Not ready')
    // slug with simple client-side uniqueness
    let slug = slugify(name)
    const existing = (data || []).map(v => v.slug || slugify(v.name))
    let suffix = 1
    while (existing.includes(slug)) { slug = `${slug}-${suffix++}` }
    if (isDefault) {
      await supabase.from('saved_views').update({ is_default: false }).eq('tenant_id', activeTenantId).eq('user_id', user.id).eq('is_default', true)
    }
    const { data: created, error } = await supabase
      .from('saved_views')
      .insert([{ tenant_id: activeTenantId, user_id: user.id, name, slug, filters_json: filters, is_default: !!isDefault, shared_to_all: !!sharedToAll }])
      .select()
      .single()
    if (error) throw error
    await mutate()
    setActiveViewId(created?.id ?? null)
    return created as SavedView
  }, [activeTenantId, user, mutate, data, setActiveViewId])

  const setDefault = useCallback(async (id: string) => {
    if (!activeTenantId || !user) throw new Error('Not ready')
    await supabase.from('saved_views').update({ is_default: false }).eq('tenant_id', activeTenantId).eq('user_id', user.id)
    await supabase.from('saved_views').update({ is_default: true }).eq('id', id).eq('tenant_id', activeTenantId).eq('user_id', user.id)
    await mutate()
  }, [activeTenantId, user, mutate])

  const remove = useCallback(async (id: string) => {
    await supabase.from('saved_views').delete().eq('id', id)
    await mutate()
  }, [mutate])

  const update = useCallback(async (id: string, patch: Partial<{ name: string; filters_json: SavedViewFilters; is_default: boolean; shared_to_all: boolean; slug?: string }>) => {
    if (patch.is_default) {
      const row = await supabase.from('saved_views').select('tenant_id,user_id').eq('id', id).single()
      const t = row.data?.tenant_id; const u = row.data?.user_id
      if (t && u) await supabase.from('saved_views').update({ is_default: false }).eq('tenant_id', t).eq('user_id', u)
    }
    // Auto-slugify on rename if slug not provided
    if (patch.name && !patch.slug) {
      patch.slug = slugify(patch.name)
    }
    await supabase.from('saved_views').update(patch).eq('id', id)
    await mutate()
  }, [mutate])

  const predefined = useMemo(() => {
    const items: { name: string; filters: SavedViewFilters }[] = [
      { name: 'Heute', filters: { logic: 'AND', onlyToday: true } },
      { name: 'Überfällig', filters: { logic: 'AND', priorities: ['overdue'] } },
      { name: 'Auto-FUs', filters: { logic: 'AND', autoGenerated: 'auto' } },
      { name: 'Meine Leads', filters: { logic: 'AND', owners: user?.id ? [user.id] : [] } },
    ]
    return items
  }, [user?.id])

  const activeView = useMemo(() => (data || []).find(v => v.id === activeViewId) || null, [data, activeViewId])

  return { views: data || [], loading: isLoading, error, mutate, create, update, remove, setDefault, predefined, activeViewId, setActiveViewId, activeView }
}


